# Математика

## Определение простоты числа

### Задача: определить является ли число простым?

У любого числа всегда есть делитель, не превосходящий корня из этого числа. 
Тогда перебор можно заканчивать после достижения корня.

### Сложность: O(√n)

### C++
```cpp
bool is_prime(int n) {
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```
---
## Факторизация числа

Факторизация — это разложение числа в произведение простых делителей. 
По основной теореме арифметики такое разложение единственно.

### Задача: факторизовать число.

Будем передавать в функцию ссылки на два вектора, в которых будет храниться ответ — вектор самих простых чисел и степени, в которых эти числа входят в разложение.

Если очередное *i* не является делителем *n*, то ничего не делаем, переходим к следующей итерации. Если же делит, то добавляем его в вектор простых делителей, а в вектор степеней добавляем 0. 
Затем считаем, в какой степени простой делитель входит в разложение, деля *n* на *i*, пока делится и инкрементируя степень *alpha[i]*.

### Сложность: Сложность. В худшем случае, то есть когда факторизуемое число простое, сложность этого алгоритма будет также O(√n).

### C++
```cpp
void factorization(int n, vector<int>& prime, vector<int>&alpha) {
    
    for(int i = 2; i * i <= n; ++i) {
        if (n % i != 0)
            continue;
        
        prime.push_back(i);
        alpha.push_back(0);
        while (n % i == 0) {
            alpha.back() += 1;
            n /= i;
        }
    }

    if (n > 1) {
        prime.push_back(n);
        alpha.push_back(1);
    }
}
```
---
## Решето Эратосфена

Идея заключается в том, что мы идём слева-направо по натуральным числам от 1 до n, просматривая очередное число, определяем не вычеркнуто ли оно. Если число не вычеркнуто, то будем говорить, 
что оно простое и вычёркивать все кратные ему до n.

### Сложность: O(n log log n).

### C++
```cpp
void sieve(int n, vector<int>& result) {
    result.assign(n + 1, 0);
    result[0] = 1;
    result[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (result[i] != 0) // true => число составное
            continue;
        for (int j = i * 2; j <= n; j += i) {
            result[j] = 1;
        }
    }
}
```
---
## Алгоритм Евклида

### C++
```cpp
int gcd(int a, int b) {
    while (a != 0) {
        b %= a;
        swap(a, b);
    }
    return b;
}

// Или так
int gcd(int a, int b) {
    return a == 0 ? b : gcd(b % a, a);
}
```
---
## Бинарное возведение в степень

### Сложность: O(log n)

### C++
```cpp
int bin_pow(int a, int n) {
    int res = 1;
    while (n > 0) {
        if (n % 2 == 1)
            res = res * a;
        a = a * a;
        n /= 2;
    }
    return res;
}
```

Предположим, мы правда хотим возводить в очень большие степени, например 1000000. 
В long long числа в такой степени точно не влезут. Значит, скорее всего, нам нужно будет возводить числа по модулю какого-то числа.

```cpp
int bin_pow(int a, int n, int mod) {
    int res = 1;
    while (n > 0) {
        if (n % 2 == 1)
            res = (res * a) % mod;
        a = (a * a) % mod;
        n /= 2;
    }
    return res;
}
```
---
## Малая теорема Ферма и обратный элемент в кольце по простому модулю

Если p простое и a не делится на p, то $`a^{(p−1)} ≡ 1 (mod p).`$

$`a^{p−1} = a · a^{(p−2)} ≡ 1 (mod p)`$ что значит, обратный элемент по простому модулю от a равен $`a^{(p−2)}`$.

### Функция Эйлера
φ(m) — это так называемая функция Эйлера, которая равна количеству натуральных чисел, меньших m, взаимнопростых с ним.
#### Сложность: O(√n)
#### C++
```cpp
int euler(int n) {
    int res = n;
    for (int i = 2; i * i <= n; i++) {
        if (n % i != 0)
            continue;
        while (n % i == 0) {
            n /= i;
        }
        res = (res - res / i);
    }
    if (n > 1) {
        res = (res - res / n);
    }
    return res;
}
```

### Обратный элемент по модулю
```cpp
int inv_a = bin_pow(a, euler(mod) - 1, mod);
```
---
## Комбинаторика

### Правило сложения
Если элемент **A** можно выбрать *n* способами, а элемент **B** можно 
выбрать *m*, то выбрать **A** или **B** можно *n + m* способами.

### Правило умножения
Если элемент **A** можно выбрать *n* способами, и при любом выборе **A**
элемент **B** можно выбрвть *m* способами, то пару **(A, B)** можно выбрать
*n · m* способами.

### Число перестановок.
Перестановка из *n* элементов — это упорядоченный набор из *n* различных чисел от 1 до n.

Количество различных перестановок из n элементов равно факториалу от n: 
**n! = 1 · 2 · 3 · . . . · n**. Также отдельно указывается, что 0! = 1.

### Число размещений.
Сколькими способами можно разместить k элементов из последова-
тельности 1, 2, . . . , n. Притом размещения, в которых будут одинаковые
элементы, стоящие в разном порядке, считаются разными.

$`A = \frac{n!}{(n-k)!}`$

### Число сочетаний
Под числом сочетаний понимается количество вариантов выбрать k
элементов из некоторого множества, состоящего из n элементов.

$`C_{n}^{k} = \frac{n!}{(n-k)!k!}`$

```cpp
int C(int n, int k) {
    int res = 1;
    for (int i = k + 1; i <= n; i++)
        res = res * i;
    for (int i = 2; i <= n - k; i++)
        res = res / i;
    return res;
}
```
### Сложность: O(n)
