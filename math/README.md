# Математика

## Определение простоты числа

### Задача: определить является ли число простым?

У любого числа всегда есть делитель, не превосходящий корня из этого числа. 
Тогда перебор можно заканчивать после достижения корня.

### Сложность: O(√n)

### C++
```cpp
bool is_prime(int n) {
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```
---
## Факторизация числа

Факторизация — это разложение числа в произведение простых делителей. 
По основной теореме арифметики такое разложение единственно.

### Задача: факторизовать число.

Будем передавать в функцию ссылки на два вектора, в которых будет храниться ответ — вектор самих простых чисел и степени, в которых эти числа входят в разложение.

Если очередное *i* не является делителем *n*, то ничего не делаем, переходим к следующей итерации. Если же делит, то добавляем его в вектор простых делителей, а в вектор степеней добавляем 0. 
Затем считаем, в какой степени простой делитель входит в разложение, деля *n* на *i*, пока делится и инкрементируя степень *alpha[i]*.

### Сложность: Сложность. В худшем случае, то есть когда факторизуемое число простое, сложность этого алгоритма будет также O(√n).

### C++
```cpp
void factorization(int n, vector<int>& prime, vector<int>&alpha) {
    
    for(int i = 2; i * i <= n; ++i) {
        if (n % i != 0)
            continue;
        
        prime.push_back(i);
        alpha.push_back(0);
        while (n % i == 0) {
            alpha.back() += 1;
            n /= i;
        }
    }

    if (n > 1) {
        prime.push_back(n);
        alpha.push_back(1);
    }
}
```
---
## Решето Эратосфена

Идея заключается в том, что мы идём слева-направо по натуральным числам от 1 до n, просматривая очередное число, определяем не вычеркнуто ли оно. Если число не вычеркнуто, то будем говорить, 
что оно простое и вычёркивать все кратные ему до n.

### Сложность: O(n log log n).

### C++
```cpp
void sieve(int n, vector<int>& result) {
    result.assign(n + 1, 0);
    result[0] = 1;
    result[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (result[i] != 0) // true => число составное
            continue;
        for (int j = i * 2; j <= n; j += i) {
            result[j] = 1;
        }
    }
}
```
---
## Алгоритм Евклида

### C++
```cpp
int gcd(int a, int b) {
    while (a != 0) {
        b %= a;
        swap(a, b);
    }
    return b;
}

// Или так
int gcd(int a, int b) {
    return a == 0 ? b : gcd(b % a, a);
}
```
