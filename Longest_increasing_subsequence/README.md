## Задача:
Дан массив из n чисел: a[0..n-1]. Требуется найти в этой последовательности *строго возрастающую подпоследовательность* наибольшей длины.

**Наибольшая возрастающая подпоследовательность** (НВП) (англ. Longest increasing subsequence, LIS) строки x длины n — это 
последовательность x[i1]<x[i2]<⋯<x[ik] символов строки x таких, что i1<i2<⋯<ik,1⩽ij⩽n, причем k — наибольшее из возможных.

## Решение за время O(n^2)
Построим массив d, где d[i] — это длина наибольшей возрастающей подпоследовательности, оканчивающейся в элементе, с индексом i. 
Массив будем заполнять постепенно — сначала d[0], потом d[1] и т.д. Ответом на нашу задачу будет максимум из всех элементов массива d. 
Заполнение массива будет следующим: если d[i]=1, то искомая последовательность состоит только из числа a[i]. 
Если d[i]>1, то перед числом a[i] в подпоследовательности стоит какое-то другое число. Переберем его: это может быть любой элемент a[j] (j=0...i−1), 
но такой, что a[j]<a[i]. Пусть на каком-то шаге нам надо посчитать очередное d[i]. Все элементы массива d до него уже посчитаны. 
Значит наше d[i] мы можем посчитать следующим образом: $`d[i]=1+max_{j=0..i−1}d[j]`$ при условии, что a[j]<a[i].

Пока что мы нашли лишь максимальную длину наибольшей возрастающей подпоследовательности, но саму ее мы вывести не можем. Для восстановления ответа заведем массив prev[0...n−1], 
где prev[i] будет означать индекс в массиве a[], при котором достигалось наибольшее значение d[i]. Для вывода ответа будем идти от элемента с максимальным значениям d[i] по его предкам.

```cpp
int d[MAXN], p[MAXN]; // константа MAXN равна наибольшему возможному значению n

for(int i=0; i<n; ++i) {
  d[i] = 1;
  p[i] = -1;
  for (int j=0; j<i; ++j)
    if (a[j] < a[i])
      if (1 + d[j] > d[i]) {
        d[i] = 1 + d[j];
        p[i] = j;
      }
}
 
int ans = d[0],  pos = 0;

for(int i=0; i<n; ++i){
  if(d[i] > ans) {
    ans = d[i];
    pos = i;
  }
}

cout << ans << endl;
 
vector<int> path;
while(pos != -1) {
  path.push_back(pos);
  pos = p[pos];
}

reverse(path.begin(), path.end());
for(int i=0; i<(int)path.size(); ++i)
  cout << path[i] << ' ';
```
---
## Решение за O(N log N)
Для более быстрого решения данной задачи построим следующую динамику: пусть d[i] (i=0...n) — число, на которое оканчивается
возрастающая последовательность длины i, а если таких чисел несколько — то наименьшее из них. Изначально мы предполагаем, 
что d[0]=−∞, а все остальные элементы d[i]=∞. Заметим два важных свойства этой динамики: d[i−1]⩽d[i], для всех i=1...n
и каждый элемент a[i] обновляет максимум один элемент d[j]. Это означает, что при обработке очередного a[i], мы можем за O(logn)
c помощью двоичного поиска в массиве d найти первое число, которое больше либо равно текущего a[i] и обновить его.

Для восстановления ответа будем поддерживать заполнение двух массивов: pos и prev. В pos[i] будем хранить индекс элемента, на который заканчивается оптимальная подпоследовательность длины i, 
а в prev[i] — позицию предыдущего элемента для a[i].

```cpp
vector<int> d(n);
vector<int> pos(n);
vector<int> prev(n-1);

int length = 0;

pos[0] = -1;
d[0] = -INF;

for(int i=1; i<=n; ++i)
  d[i] = INF;

for(int i=0; i<n; i++){
  int j = int(upper_bound(d.begin(), d.end(), a[i]) - d.begin());
  if(d[j-1] < a[i] && a[i] < d[j]){
    d[j] = a[i];
    pos[j] = i;
    prev[i] = pos[j - 1];
    length = max(length, j);
  }
}

vector<int> path;
int p = pos[length];

while(p != -1){
  path.push_back(a[p]);
  p = prev[p];
}

reverse(path.begin(), path.end());

for(int i=0; i<(int)path.size(); ++i)
  cout << path[i] << ' ';
```

